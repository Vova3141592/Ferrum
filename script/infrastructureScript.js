'use strict';

const text = {

    server: "<div>Что такое сервер на самом деле?</div><div>Слово «serve» переводится как «обслуживать», тогда слово «server» переводится как «обслуживатель».</div><div>Сервер - это программа, которая обслуживает <u id='underline1' onclick='explanation(`serverClients`, underline1)'>клиентов</u>. Ещё так называют компьютеры, на которых работают такие программы.</div><div>Примеры программ-серверов:<br>- любой игровой сервер, например Bukkit, Spigot (это игровые серверы Minecraft);<br>- файловый сервер, например в колледже есть сетевая папка Study (она работает с помощью программы-сервера «служба сервер» в Windows);<br>- веб-сервер, чтобы компьютер мог показывать сайты клиентам, например Apache, Nginx;<br>- VPN-сервер - это программа, чтобы клиенты могли подключаться к какому-нибудь компьютеру в другой стране, создавать защищённый туннель и заходить на заблокированные сайты. Примеры программ - WireGuard, OpenVPN.</div><div>Вот так выглядит взаимодействие сервера и клиента:</div><div>Сервер ←→ Клиент ←→ Пользователь</div><div>Пример: есть веб-сервер Apache - это программа, с помощью которой работают сайты. Эта программа работает на каком-то компьютере, который тоже можно назвать сервером. Есть клиент - это браузер, которые отправляет запрос веб-серверу и получает страницу сайта. Клиентом аналогично можно назвать компьютер пользователя.</div><div>Обычно клиентов много, сервер один.</div><div class='img'><img src='../img/server.png' alt='Что такое сервер'></div><div>К чему это всё? Я хочу, чтобы вы уяснили очень простую мысль: сервер - это всего лишь программа. А то, что мы называем так сами компьютеры, - это просто для удобства.</div><div>Поэтому, на самом деле, сервером может быть какой угодно компьютер. Например, если вы поставите программу-сервер Apache на свой смартфон, то смартфон станет сервером. Если вы поставите какую-нибудь программу-сервер на калькулятор, он тоже станет сервером.</div><div>Конечно, существуют специальные компьютеры, сделанные специально для программ-серверов, чтобы эффективнее обслуживать клиентов. У них память с коррекцией ошибок, много жёстких дисков, объединённых в RAID-массив и процессор с большим количеством медленных ядер. Но это всё вторично, это просто как бонус. Компьютеру не обязательно быть специальным, чтобы работать как сервер - достаточно лишь программ-серверов.</div><div>Как это знание может вам пригодиться? Допустим, вам понадобится сделать сервер. Можно не покупать отдельный компьютер, а просто установить программу-сервер на свой компьютер. Тогда ваш компьютер будет и клиентом, и сервером одновременно. Ваш компьютер сможет и работать с вами как с пользователем, и с клиентами.</div><div>Например, когда вы открываете в Minecraft'е мир для сети, ваш компьютер становится сервером. Вы и сами можете играть в своём мире, ещё в ваш мир могут зайти друзья. Сам мир находится на вашем компьютере, но друзья смогут с вами играть, потому что ваш сервер будет обслуживать их клиенты.</div><div>Если вы не хотите, чтобы работа программ-серверов и обслуживание клиентов сказывалась на производительности вашего устройства, сделайте сервер из лишнего устройства, которым вы не пользуетесь. Например, хороший вариант сделать сервер из ноутбука:<br>- ноутбуки имеют батарейку, она будет работать как источник бесперебойного питания;<br>- ноутбуки тихие, поэтому не будут раздражать ночью, когда вы ложитесь спать;<br>- ноутбуки потребляют мало энергии, поэтому не придётся платить очень много за электричество, даже если ноутбук будет работать круглосуточно.</div><div>Нужно будет просто установить программу-сервер на ноутбук и поставить его куда-нибудь в укромное место, чтобы он работал круглый день и не мешался вам (но это место не должно быть в шкафу: нужно свободное место для циркуляции воздуха, чтобы устройство могло охлаждаться).</div><div>Кстати, если вы хотите сделать сервер из отдельного устройства, на котором сами уже ничего не делаете, лучше поставьте туда любую операционную систему Linux. Linux бесплатный, он стабильнее, чем Windows, большинство программ-серверов сделано именно для Linux, они тоже бесплатные, Linux требует намного меньше оперативной памяти (например, Debian + окружение рабочего стола Xfce занимают всего 800 МБ оперативной памяти, а Windows 10 занимает 2000 МБ).</div><div>Вывод из всей этой истории: хотя наша тема - это железо, но я хочу вам показать, что для того, чтобы сделать сервер, совсем не обязательно покупать это самое железо. Так что на железе можно очень хорошо сэкономить, если его вообще не покупать, а сделать сервер из подручных средств.</div>",

    serverClients: "<div>Клиенты - это тоже программы, но с ними уже взаимодействуют пользователи. Аналогично так можно называть компьютеры, на которых работают программы-клиенты. Примеры программ-клиентов:<br>- браузер,<br>- игра (когда ты играешь по сети, есть две части игры: сервер, где происходит взаимодействие пользователей, и клиент, на котором ты играешь, который отображает тебе всё, что происходит в игре).</div>",

    networkOS: "<div>то есть могут без проблем брать любые файлы из сети, как будто эти файлы находятся прямо на том компьютере, где эти ОС работают. Например, можно создать сетевые папки, а потом указать в программах пути для сохранения файлов в эти папки. Или указать, что будет использоваться БД, расположенная по определённому IP-адресу и с определённым портом. Вот, что такое <u id='underline1' onclick='explanation(`networkOS`, underline1)'>сетевая</u> ОС.</div>",

    vdiGeneral: "<div>Это не обязательный элемент конвергентной инфраструктуры, но он позволяет сделать ещё больше централизации: чтобы всё стало ещё более сконцентрированным.</div><div>Что такое виртуальные рабочие места? Это такая технология, что компьютеры нужны только для доступа на сервер. Когда ты включаешь компьютер, он загружает операционную систему не у себя, а ту, которая находится на сервере. И вычисления все происходят тоже на сервере. И данные хранятся на сервере. Сам компьютер нужен только для загрузки операционной системы, которая находится на сервере, и для вывода изображения на экран.</div><div>Как такое сделать? Есть два способа:<br>- <u id='underline1' onclick='explanation(`vdiTechnology`, underline1)'>VDI</u> (Virtual Desktop Infrastructure) - на сервер устанавливается <u id='underline2' onclick='explanation(`broker`, underline2)'>брокер подключений</u>, <u id='underline3' onclick='explanation(`hypervisor`, underline3)'>гипервизор</u> и куча <u id='underline4' onclick='explanation(`virtualMachine`, underline4)'>виртуальных машин</u>;<br>- <u id='underline5' onclick='explanation(`terminalServer`, underline5)'>терминальный сервер</u> - на сервере нужна просто многопользовательская операционная система (ОС), а компьютеры подключаются к этому серверу с помощью протокола удалённого рабочего стола.</div>",

    vdiTechnology: "<div>VDI состоит из <u id='underline1' onclick='explanation(`clients`, underline1)'>клиентов</u>, <u id='underline2' onclick='explanation(`broker`, underline2)'>брокера подключений</u>, <u id='underline3' onclick='explanation(`hypervisor`, underline3)'>гипервизора</u> и <u id='underline4' onclick='explanation(`virtualMachine`, underline4)'>виртуальных машин</u>:</div><div class='img'><img src='../img/vdi.png' alt='VDI'></div><div>На картинке нет коммутатора и маршрутизатора, я их для простоты убрал.</div><div>VDI обычно делается с помощью специальной программы, в которой есть все эти функции. Вот самые лучшие варианты:</div><div>1. Есть целая куча программ от VMWare, комбинируя которые, можно получить VDI (но это платные программы). Это должен быть самый продвинутый вариант. Но сложный и дорогой.</div><div>2. Можно сделать VDI с помощью специальной роли «VDI» в Windows Server (Windows Server - платная ОС, но роль «VDI» бесплатная). Получается наполовину платно и делается легко.</div><div>3. Можно использовать OpenUDS - это программа, с помощью которой делается VDI бесплатно. Работает на Linux. Наверное, делается не очень легко, ведь это Linux.</div>",

    clients: "<div>Клиенты - это обычные компьютеры, вычисления на которых не происходят. Они нужны для подключения к серверу, чтобы вычисления производились на виртуальных машинах, расположенных на сервере.</div>",

    broker: "<div>Брокер подключений - это такая штука, которая нужна для балансировки нагрузки. Она определяет, к какой виртуальной машине подключить того или иного клиента.</div>",

    hypervisor: "<div>Что такое гипервизор? Это такая программа, которая позволяет запускать внутри компьютера другие компьютеры. Например, программа VirtualBox:</div><div class='img'><img src='../img/vb.png' alt='Программа-гипервизор VirtualBox'></div><div>С помощью гипервизора можно запускать разные операционные системы внутри одной операционной системы. Обычно они для этого и используются.</div><div>Вот эти «компьютеры в компьютере» - это и есть виртуальные машины.</div><div>Чтобы виртуальные машины работали, происходит <u id='underline1' onclick='explanation(`imitation`, underline1)'>имитация</u> (все это называют эмуляцией, но мне кажется, что слово «имитация» понятнее звучит). Т. е. одна ОС имитирует работу другой ОС.</div>",

    imitation: "<div>Есть разные варианты имитации:</div><div>1. Полная, когда имитируются всё: таблица страниц памяти, все операции процессора и так далее. Такой вариант самый универсальный. С помощью него из любой операционной системы можно запустить любую другую операционную систему.</div><div>2. Т. н. «паравиртуализация» - это неполный вариант виртуализации, где низкоуровневые ресурсы напрямую не имитируются. Здесь с помощью API (API (Application Programming Interface) - это, по простому говоря, кнопки, с помощью которых одна программа может управлять другой. На самом деле, кнопок нет, вместо них - команды. Какая-то программа может посылать другой программе команды, и та другая программа будет как-то на эти команды отвечать, что-то делать, в зависимости от функционала команд. В общем, у одной программы есть интерфейс, другие программы могут этим интерфейсом пользоваться, чтобы управлять этой программой. Пример API - VK API, с помощью этого API программы могут управлять социальной сетью VK) гостевые ОС используют функции хостовой ОС (гостевые ОС - это «компьютер в компьютере». Хостовая ОС - это ОС самого компьютера, как бы главная ОС, в которой «сидят» другие.), не обращаясь напрямую к низкоуровневым ресурсам. Из-за этого лишний раз эмулировать что-то не нужно, не нужно как бы изобретать велосипед, поэтому скорость повышается. Но в таком случае гостевые ОС обязательно должны быть с открытым исходным кодом, чтобы их можно было модифицировать для паравиртуализации. Так что это менее универсальный способ. И гостевую ОС нужно переделывать (т. е. нужно будет где-то скачать специальный вариант ОС, чтобы он работал с паравиртуализацией). Пример гипервизора с паравиртуализацией - Xen.</div><div>3. Контейнеризация - это способ виртуализации, где гостевые ОС используют ядро хостовой ОС. Это самый быстрый способ, потому что по факту ядро ОС одно, разное только то, что сверху. Пример такого гипервизора - OpenVZ. Падение производительности гостевых ОС с таким гипервизором по сравнению с обычным вариантом установки всего 1-3%. Но у гипервизора OpenVZ есть куча недостатков: хостовой ОС должен быть Linux, но не любой, а с определённой версией ядра. Хостовыми ОС тоже может быть только Linux с той же версией ядра. Есть ещё популярная программа для контейнеризации Docker, у неё такая особенность, что она пытается имитировать работу не целой ОС, а отдельного приложения, но так, что это приложения как будто находится в определённой ОС. То есть это ещё более облегчённый вариант виртуализации. Как это можно использовать? Например, если кто-нибудь сделал программу для Linux, её можно засунуть в контейнер и запустить в Windows. Она будет работать на ядре Linux, но внутри Windows. Правда, в таком случае скорость получится небольшой, потому что ядро Linux будет работает поверх Windows. Чтобы скорость была большой, контейнер Docker нужно запускать в такой ОС, которая использует то же ядро, что и программа, которую вы засунули в контейнер. Т. е. если программа в контейнере работает на Linux, то и хостовая ОС тоже должна быть на Linux.</div>",

    virtualMachine: "<div>Виртуальная машина - это «компьютер в компьютере». Это операционная система, работающая внутри другой операционной системы. Кстати, та ОС, которая находится внутри, называется «гостевой», а та, внутри которой находится гостевая ОС, называется «хостовой» ОС. ОС можно запускать внутри друг друга с помощью программы-гипервизора.</div>",

    terminalServer: "<div>Терминальный сервер - это ещё один способ сделать так, чтобы использовать слабые компьютеры просто как посредников, а все вычисления производить на сервере и данные хранить тоже на каком-нибудь сервере.</div><div>Терминальный сервер отличается от VDI тем, что здесь нет отдельных ОС для каждого пользователя. Вместо этого здесь одна многопользовательская ОС, к которой пользователи подключаются с помощью какого-нибудь протокола удалённого рабочего стола.</div><div>Наверное, все знают, что в Windows может быть несколько пользователей:</div><div class='img'><img src='../img/dz.png' alt='Диспетчер задач, один пользователь'></div><div>На картинке пользователь один, но их может быть много.</div><div>Именно так это и работает. Можно создать на сервере пользователей, раздать им права, а потом эти пользователи с других компьютеров с помощью протокола удалённого рабочего стола (например, RDP в Windows или XRDP в Linux) подключатся к этому серверу и будут на нём работать. </div><div>Терминальный сервер можно сделать 3 способами:</div><div>1. LTSP - это набор программ для Linux, который позволяет превратить ОС Linux в полноценный терминальный сервер.</div><div>2. Просто один протокол удалённого рабочего стола xrdp + многопользовательская ОС Linux, например Xubuntu. Это очень простой способ сделать бесплатный Терминальный сервер. В нашем колледже именно таким образом сделан доступ к программе 1С. Не знаю, как сейчас, но в 2022 году было так.</div><div>3. RDC - это служба в Windows Server, которая делает полноценный терминальный сервер. Простой способ, только Windows Server платная.</div><div>В отличие от VDI, в терминальном сервере у пользователей нет отдельных ОС. Поэтому, если у кого-нибудь из-за ошибки программы зависнет вся ОС, то зависнет всё и у других пользователей. Придётся весь сервер перезагружать. Но такой способ намного оптимизированнее, потому что ОС одна на всех. Меньше оперативной памяти нужно, меньше постоянной памяти, меньше времени процессорного нужно.</div><div>Что лучше - VDI или терминальный сервер? VDI технически лучше, потому что у всех пользователей своя отдельная ОС, которую можно переделать под себя, можно использовать права администратора, при зависании одной ОС все остальные продолжают работать, все пользователи изолированы друг от друга, поэтому в случае заражения вирус не сможет распространиться за пределы заражённой ВМ (если в сети исходящие соединения от этой ВМ запрещены), можно делать удобно резервное копирование (снимки состояния ВМ (снимки состояния - это как будто ты берёшь ВМ, копируешь её, замораживаешь и ложишь в морозилку лежать, пока она тебе снова не понадобится. Потом, допустим, ВМ сломалась. Либо сервер сгорел, либо ОС в виртуальной машине по какой-то причине поломалась, что нужно переустанавливать. Тогда берёшь из морозилки снимок состояния, загружаешь его куда-то в гипервизор (где-то в программе для этого должно быть специальное место, куда можно загрузить), и всё работает, как будто ты просто отмотал время назад, в то место, откуда ты делал снимок. В общем, как будто точка восстановления. Всё просто.).</div><div>У терминального сервера нет всех этих преимуществ. Вместо этого он просто намного лучше оптимизирован. Ещё терминальный сервер легче настроить.</div><div>Таким образом, если у вас куча денег или слишком мощный сервер, лучше сделать VDI. Если ваша цель сэкономить и сделать быстро - придётся использовать терминальный сервер.</div>",

    // menu
    
    theory: "<div><a class='button' href='server.html'>▶ Что такое сервер на самом деле?</a></div><div><a class='button' href='infrastructure.html'>▶ Какие бывают виды ИТ-инфраструктуры?</a></div><div><a class='button' href='electricity.html'>▶ Как работает электричество?</a></div>",
    building: "<div><a class='button' href='server.html'>▶ Где искать комплектующие?</a></div><div><a class='button' href='infrastructure.html'>▶ Как собирать?</a></div><div><a class='button' href='electricity.html'>▶ Как обслуживать?</a></div>",
    zapaska: "<div><a class='button' href='server.html'>▶ Что за принцип такой?</a></div>",
    search: "<div><a class='button' href='server.html'>▶ Как искать причины неисправностей?</a></div><div><a class='button' href='infrastructure.html'>▶ Как устранять неисправности?</a></div>",
    tricks: "<div><a class='button' href='server.html'>▶ Разные трюки с гаджетами</a></div><div><a class='button' href='infrastructure.html'>▶ Мифы о компьютерах</a></div>",
};

let push = {};

function explanation(name, place) {
    if (push[place.id] == true) {
        hideExplanation(place); // если вставлено, скрываем
    } else if (push[place.id] == false) {
        showExplanation(place); // если скрыто, показываем
    } else {
        pasteExplanation(name, place); // если не определено, вставляем
    };
};

function hideExplanation(place) {
    document.getElementById('d' + place.id).classList.toggle('hide');
    push[place.id] = false;
};

function showExplanation(place) {
    document.getElementById('d' + place.id).classList.toggle('hide');
    push[place.id] = true;    
};

function pasteExplanation(name, place) {
    let element = document.createElement('div');
    element.className = 'explanation';
    element.id = 'd' + place.id;
    element.innerHTML = getText(name, place);
    place.after(element);
    push[place.id] = true;
};

function getText(name, place) {
    let modifiedText = text[name].replace(/underline\d/g, place.id + '$&' );
    return modifiedText; 
};